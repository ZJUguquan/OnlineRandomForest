tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
?CDTM
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
# Tree ------------------------
Tree <- R6Class(
public = list(
elem = NULL, left = NULL, right = NULL, node.ind = NULL,
initialize = function(elem = NULL, left = NULL, right = NULL, node.ind = 1) {
stopifnot((is.null(left) & is.null(right)) |
sum(c(class(left), class(right)) == "Tree") == 2)
self$elem <- elem
self$left <- left
self$right <- right
self$node.ind <- node.ind
},
generateTree = function(tree.mat, node.ind = 1) {
row <- tree.mat[node.ind, ]
if (row[["status"]] != -1) {
self$elem <- list(splitInd = row[["split var"]], splitVal = row[["split point"]])
self$elem$toString <- function() {
paste0("X", self$elem$splitInd, " < ", self$elem$splitVal)
# paste0("X", eval(self$elem$splitInd), " < ", eval(self$elem$splitVal))
# paste0("X", eval(parse(text = "self$elem$splitInd")), " < ", eval(parse(text = "self$elem$splitVal")))
}
self$left <- Tree$new(node.ind = row[["left daughter"]])
self$left$generateTree(tree.mat, row[["left daughter"]])
self$right <- Tree$new(node.ind = row[["right daughter"]])
self$right$generateTree(tree.mat, row[["right daughter"]])
} else {
self$elem <- row[["prediction"]]
}
},
updateChildren = function(l, r) {
self$left <- l
self$right <- r
},
isLeaf = function() {
is.null(self$left) & is.null(self$right)
},
size = function() {
if (self$isLeaf()) 1 else { self$left$size() + self$right$size() + 1 }
},
numLeaves = function() {
if (self$isLeaf()) 1 else { self$left$numLeaves() + self$right$numLeaves() }
},
depth = function() {
if (self$isLeaf()) 0 else { max(self$left$depth(), self$right$depth()) + 1 }
},
draw = function(depth = 0, side = "none") {
if ("toString" %in% names(self$elem)) {
elem <- self$elem$toString()
} else {
elem <- self$elem
}
if (depth == 0) {
cat("Note: if condition satisfied, go L(Left), otherwise R(Right).\n\n")
cat("Root", elem, "\n")
}
prefix = paste0(rep("     ", max(depth-1, 0)), collapse = "")
prefix = paste0(prefix, switch(side, left = "|----L:", right = "|----R:", none = ""))
if (self$isLeaf()) {
cat(prefix, "Leaf", elem, "\n")
} else {
if (depth != 0) cat(prefix, elem, "\n")
self$left$draw(depth+1, "left")
self$right$draw(depth+1, "right")
}
}
)
)
ta <- Tree$new("abc", NULL, NULL)
tb <- Tree$new(1, Tree$new(36), Tree$new(3))
tc <- Tree$new(89, tb, ta)
td <- Tree$new("guquan", tc, tb)
tb$draw()
tb$size()
tb$maxDepth()
tc$draw()
tc$maxDepth()
tc$right$updateChildren(Tree$new("666"), Tree$new(999))
tc$right$right$updateChildren(Tree$new("666"), Tree$new(999))
tc$draw()
td$draw()
# Tree ------------------------
Tree <- R6Class(
public = list(
elem = NULL, left = NULL, right = NULL, node.ind = NULL,
initialize = function(elem = NULL, left = NULL, right = NULL, node.ind = 1) {
stopifnot((is.null(left) & is.null(right)) |
sum(c(class(left), class(right)) == "Tree") == 2)
self$elem <- elem
self$left <- left
self$right <- right
self$node.ind <- node.ind
},
generateTree = function(tree.mat, node.ind = 1) {
row <- tree.mat[node.ind, ]
if (row[["status"]] != -1) {
self$elem <- list(splitInd = row[["split var"]], splitVal = row[["split point"]])
self$elem$toString <- function() {
paste0("X", self$elem$splitInd, " < ", self$elem$splitVal)
# paste0("X", eval(self$elem$splitInd), " < ", eval(self$elem$splitVal))
# paste0("X", eval(parse(text = "self$elem$splitInd")), " < ", eval(parse(text = "self$elem$splitVal")))
}
self$left <- Tree$new(node.ind = row[["left daughter"]])
self$left$generateTree(tree.mat, row[["left daughter"]])
self$right <- Tree$new(node.ind = row[["right daughter"]])
self$right$generateTree(tree.mat, row[["right daughter"]])
} else {
self$elem <- row[["prediction"]]
}
},
updateChildren = function(l, r) {
self$left <- l
self$right <- r
},
isLeaf = function() {
is.null(self$left) & is.null(self$right)
},
size = function() {
if (self$isLeaf()) 1 else { self$left$size() + self$right$size() + 1 }
},
numLeaves = function() {
if (self$isLeaf()) 1 else { self$left$numLeaves() + self$right$numLeaves() }
},
depth = function() {
if (self$isLeaf()) 0 else { max(self$left$depth(), self$right$depth()) + 1 }
},
draw = function(depth = 0, side = "none") {
if ("toString" %in% names(self$elem)) {
elem <- self$elem$toString()
} else {
elem <- self$elem
}
if (depth == 0) {
cat("Note: if condition satisfied, go L(Left), otherwise R(Right).\n\n")
cat("Root", elem, "\n")
}
prefix = paste0(rep("     ", max(depth-1, 0)), collapse = "")
prefix = paste0(prefix, switch(side, left = "|----L:", right = "|----R:", none = ""))
if (self$isLeaf()) {
cat(prefix, "Leaf", elem, "\n")
} else {
if (depth != 0) cat(prefix, elem, "\n")
self$left$draw(depth+1, "left")
self$right$draw(depth+1, "right")
}
}
)
)
ta <- Tree$new("abc", NULL, NULL)
tb <- Tree$new(1, Tree$new(36), Tree$new(3))
library(randomForest)
dat <- iris; dat[,5] <- as.integer(dat[,5])
rf <- randomForest(factor(Species) ~ ., data=dat)
treemat <- getTree(rf, 1, labelVar = F)
treemat <- cbind(treemat, node.ind = 1:nrow(treemat))
tree <- Tree$new()
tree$generateTree(treemat)
tree$draw()
tc
tb
tb <- Tree$new(1, Tree$new(36), Tree$new(3))
Tree$new(36)
class(Tree$new(36))
# Tree ------------------------
Tree <- R6Class(
classname = "Tree",
public = list(
elem = NULL, left = NULL, right = NULL, node.ind = NULL,
initialize = function(elem = NULL, left = NULL, right = NULL, node.ind = 1) {
stopifnot((is.null(left) & is.null(right)) |
sum(c(class(left), class(right)) == "Tree") == 2)
self$elem <- elem
self$left <- left
self$right <- right
self$node.ind <- node.ind
},
generateTree = function(tree.mat, node.ind = 1) {
row <- tree.mat[node.ind, ]
if (row[["status"]] != -1) {
self$elem <- list(splitInd = row[["split var"]], splitVal = row[["split point"]])
self$elem$toString <- function() {
paste0("X", self$elem$splitInd, " < ", self$elem$splitVal)
# paste0("X", eval(self$elem$splitInd), " < ", eval(self$elem$splitVal))
# paste0("X", eval(parse(text = "self$elem$splitInd")), " < ", eval(parse(text = "self$elem$splitVal")))
}
self$left <- Tree$new(node.ind = row[["left daughter"]])
self$left$generateTree(tree.mat, row[["left daughter"]])
self$right <- Tree$new(node.ind = row[["right daughter"]])
self$right$generateTree(tree.mat, row[["right daughter"]])
} else {
self$elem <- row[["prediction"]]
}
},
updateChildren = function(l, r) {
self$left <- l
self$right <- r
},
isLeaf = function() {
is.null(self$left) & is.null(self$right)
},
size = function() {
if (self$isLeaf()) 1 else { self$left$size() + self$right$size() + 1 }
},
numLeaves = function() {
if (self$isLeaf()) 1 else { self$left$numLeaves() + self$right$numLeaves() }
},
depth = function() {
if (self$isLeaf()) 0 else { max(self$left$depth(), self$right$depth()) + 1 }
},
draw = function(depth = 0, side = "none") {
if ("toString" %in% names(self$elem)) {
elem <- self$elem$toString()
} else {
elem <- self$elem
}
if (depth == 0) {
cat("Note: if condition satisfied, go L(Left), otherwise R(Right).\n\n")
cat("Root", elem, "\n")
}
prefix = paste0(rep("     ", max(depth-1, 0)), collapse = "")
prefix = paste0(prefix, switch(side, left = "|----L:", right = "|----R:", none = ""))
if (self$isLeaf()) {
cat(prefix, "Leaf", elem, "\n")
} else {
if (depth != 0) cat(prefix, elem, "\n")
self$left$draw(depth+1, "left")
self$right$draw(depth+1, "right")
}
}
)
)
ta <- Tree$new("abc", NULL, NULL)
tb <- Tree$new(1, Tree$new(36), Tree$new(3))
tc <- Tree$new(89, tb, ta)
td <- Tree$new("guquan", tc, tb)
tb$draw()
tb$size()
tb$maxDepth()
tc$draw()
tc$maxDepth()
tc$right$updateChildren(Tree$new("666"), Tree$new(999))
tc$right$right$updateChildren(Tree$new("666"), Tree$new(999))
tc$draw()
td$draw()
ta <- Tree$new("abc", NULL, NULL)
tb <- Tree$new(1, Tree$new(36), Tree$new(3))
tc <- Tree$new(89, tb, ta)
td <- Tree$new("guquan", tc, tb)
tb$draw()
tb$size()
tb$depth()
tc$draw()
tc$depth()
tc$right$updateChildren(Tree$new("666"), Tree$new(999))
tc$right$right$updateChildren(Tree$new("666"), Tree$new(999))
tc$draw()
td$draw()
rm(tree)
require("abc")
require(CTM)
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
tools::Rd2HTML("./man/SuffStats.Rd", out = "./html/SuffStats.html")
SuffStats <- R6Class(
classname = "SuffStats",
public = list(
eps = 1e-10, node.n = 0, classify = NULL,
node.counts = NULL, node.sum = NULL, node.square.sum = NULL,
initialize = function(numClasses = 0) {
self$classify = numClasses > 0
if (numClasses > 0) {
self$node.counts <- rep(0, numClasses)
} else {
self$node.sum <- 0.0
self$node.square.sum <- 0.0
}
},
update = function(y) {
self$node.n <- self$node.n + 1
if (self$classify) {
self$node.counts[y] <- self$node.counts[y] + 1 # need modify
} else {
self$node.sum <- self$node.sum + y
self$node.square.sum <- self$node.square.sum + y^2
}
},
reset = function() {
self$eps <- self$n <- self$classify <- NULL
self$node.counts <- self$node.sum <- self$node.square.sum <- NULL
},
pred = function() {
if (self$classify) {
# what if same frequency?
# name of counts?
which.max(self$node.counts)
} else {
unlist(self$node.sum / (self$node.n + self$eps))
}
},
impurity = function() {
n <- self$node.n + self$eps
if (self$classify) {
prop <- self$node.counts / n
sum(-prop * log(prop + self$eps))
} else {
pred <- self$pred()
sqrt(self$node.square.sum / n - pred^2)
}
}
)
)
sa <- SuffStats$new(numClasses = 3)
sa$update(2);sa$update(1);sa$update(2)
sa$pred()
sa$node.counts
sa$node.n
sa$impurity()
sb <- SuffStats$new(numClasses = 0)
sb$update(1);sb$update(2);sb$update(3)
sb$pred()
sb$node.sum;sb$node.square.sum
sb$impurity()
roxygenise()
tools::Rd2HTML("./man/SuffStats.Rd", out = "./html/SuffStats.html")
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
tools::Rd2HTML("./man/SuffStats.Rd", out = "./html/SuffStats.html")
tools::Rd2HTML("./man/Test.Rd", out = "./html/Test.html")
roxygenise()
tools::Rd2HTML("./man/Tree.Rd", out = "./html/Tree.html")
tools::Rd2HTML("./man/SuffStats.Rd", out = "./html/SuffStats.html")
tools::Rd2HTML("./man/Test.Rd", out = "./html/Test.html")
ls()
Tree <- R6Class(
classname = "Tree",
public = list(
elem = NULL, left = NULL, right = NULL, node.ind = NULL,
initialize = function(elem = NULL, left = NULL, right = NULL, node.ind = 1) {
stopifnot((is.null(left) & is.null(right)) |
sum(c(class(left), class(right)) == "Tree") == 2)
self$elem <- elem
self$left <- left
self$right <- right
self$node.ind <- node.ind
},
generateTree = function(tree.mat, node.ind = 1) {
row <- tree.mat[node.ind, ]
if (row[["status"]] != -1) {
self$elem <- list(splitInd = row[["split var"]], splitVal = row[["split point"]])
self$elem$toString <- function() {
paste0("X", self$elem$splitInd, " < ", self$elem$splitVal)
# paste0("X", eval(self$elem$splitInd), " < ", eval(self$elem$splitVal))
# paste0("X", eval(parse(text = "self$elem$splitInd")), " < ", eval(parse(text = "self$elem$splitVal")))
}
self$left <- Tree$new(node.ind = row[["left daughter"]])
self$left$generateTree(tree.mat, row[["left daughter"]])
self$right <- Tree$new(node.ind = row[["right daughter"]])
self$right$generateTree(tree.mat, row[["right daughter"]])
} else {
self$elem <- row[["prediction"]]
}
},
updateChildren = function(l, r) {
self$left <- l
self$right <- r
},
isLeaf = function() {
is.null(self$left) & is.null(self$right)
},
size = function() {
if (self$isLeaf()) 1 else { self$left$size() + self$right$size() + 1 }
},
numLeaves = function() {
if (self$isLeaf()) 1 else { self$left$numLeaves() + self$right$numLeaves() }
},
depth = function() {
if (self$isLeaf()) 0 else { max(self$left$depth(), self$right$depth()) + 1 }
},
draw = function(depth = 0, side = "none") {
if ("toString" %in% names(self$elem)) {
elem <- self$elem$toString()
} else {
elem <- self$elem
}
if (depth == 0) {
cat("Note: if condition satisfied, go L(Left), otherwise R(Right).\n\n")
cat("Root", elem, "\n")
}
prefix = paste0(rep("     ", max(depth-1, 0)), collapse = "")
prefix = paste0(prefix, switch(side, left = "|----L:", right = "|----R:", none = ""))
if (self$isLeaf()) {
cat(prefix, "Leaf", elem, "\n")
} else {
if (depth != 0) cat(prefix, elem, "\n")
self$left$draw(depth+1, "left")
self$right$draw(depth+1, "right")
}
}
)
)
SuffStats <- R6Class(
classname = "SuffStats",
public = list(
eps = 1e-10, node.n = 0, classify = NULL,
node.counts = NULL, node.sum = NULL, node.square.sum = NULL,
initialize = function(numClasses = 0) {
self$classify = numClasses > 0
if (numClasses > 0) {
self$node.counts <- rep(0, numClasses)
} else {
self$node.sum <- 0.0
self$node.square.sum <- 0.0
}
},
update = function(y) {
self$node.n <- self$node.n + 1
if (self$classify) {
self$node.counts[y] <- self$node.counts[y] + 1 # need modify
} else {
self$node.sum <- self$node.sum + y
self$node.square.sum <- self$node.square.sum + y^2
}
},
reset = function() {
self$eps <- self$n <- self$classify <- NULL
self$node.counts <- self$node.sum <- self$node.square.sum <- NULL
},
pred = function() {
if (self$classify) {
# what if same frequency?
# name of counts?
which.max(self$node.counts)
} else {
unlist(self$node.sum / (self$node.n + self$eps))
}
},
impurity = function() {
n <- self$node.n + self$eps
if (self$classify) {
prop <- self$node.counts / n
sum(-prop * log(prop + self$eps))
} else {
pred <- self$pred()
sqrt(self$node.square.sum / n - pred^2)
}
}
)
)
Test <- R6Class(
Test <- R6Class(
Test <- R6Class(
Test <- R6Class(
classname = "Candidate Split",
public = list(
classify = NULL, xvar.index = NULL, xvar.value = NULL,
statsL = NULL, statsR = NULL,
initialize = function(xvar.index, xvar.value, numClasses = 0) {
self$classify <- numClasses > 0
self$xvar.index <- xvar.index
self$xvar.value <- xvar.value
self$statsL <- SuffStats$new(numClasses = numClasses)
self$statsR <- SuffStats$new(numClasses = numClasses)
},
update = function(x, y) {
if (x[self$xvar.index] < self$xvar.value) {
self$statsL$update(y)
} else {
self$statsR$update(y)
}
}
)
)
t1 <- Test$new(3, 2.2, 0)
t1$update(c(0,0,2,4), 1.2)
t1$update(c(0,0,1,4), 1.4)
t1$update(c(1,1,3,3), 2.7)
t1$statsL$pred()
t1$statsR$pred()
closeAllConnections()
rm(list=ls())
gc()
q()
